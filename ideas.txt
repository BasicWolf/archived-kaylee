# License GPL3
System blocks
-------------
Client; Dispatcher; Controller; Storage; ProjectManager; Task;

Server-side:
Dispatcher; Controller; Storage; ProjectManager; Task;

Client-side:
Client; Task;

Communication protocol: Is based on JSON and http API. 
* Node[GET]: http://kaylee.org/register
* Node[GET]: http://kaylee.org/{node}/tasks/{task}
* Node[POST]: http://kaylee.org/{node}/tasks/{task}

==============

Case 1. A project with a fixed {1GB} amount of data divided into multiple tasks.
        Every task consists of a {64KiB} data (input) expected the same amount of
        output. ProjectManager has no function to check whether the results are 
        correct e.g. the results are subject for further complex analysis.
        In this case, the correctness of tasks is checked via
        ResultsComparisonController, which in this case requires at least 
        {two} identical outputs. BinaryStorage will serve as main storage for
        results.
----------------------------Lee-------------------------------------------------

1.1 Client1: Client enters a website. The automated script subscribes as Kaylee
             Node. 
    Dispatcher: NodeController(); PM();
    NodeController: is asked to register a new Node. The Node is assigned a
        unique id #TODO: bson-objectid-like which is based on current datetime 
        remote_addr and counter#
1.1.2 Node1: {ProjectX} is selected by the user (or hard-coded into the
             website). {ProjectX} application files are then being requested.
    Dispatcher: NodeController(); PM();
    NodeController: registers and binds the Node to {Controller}
        defined by PM.        
    PM: {ProjectX}'s manager is asked for client-side program (which is 
        basically a javascript app).
1.2 Client2: --||--

2.1 Node1: Is now ready to get a task. A task consists of parameters and/or 
           data. The parameters can come from Kaylee as well as from PM. 
           The data is always Project-specific. 
    Dispatcher: NodeController() --> {ProjectX}.Controller();
    Controller: checks if there any unsolved {ProjecX} tasks in queue? An 
        unsolved task is a task which has been sent to a Node and has 
        not been timed out yet. In this case, there are no unsolved 
        tasks, thus controller asks PM for the next unsolved task.         
        PM();
    PM: Returns task with parameters, data and ID that can be used to get the 
        same task again. #TODO: It is possible to implement caching in Controller?#
    Controller: 
        Associates the task that was retrieved from PM with an 'outer task id'.
        This is done so that every Task given to every Node has it's unique ID.
        #TODO: This ID is based on current datetime, NodeID, internal task.id and counter
2.2 Node2: --||--
    Controller: because there is an unsolved task in the queue, the controller 
        schedules the same task to Node2. Note that controller did it because
        of behaviour requested by ProjectManager. Also note that the outer 
        task ID will be different from the one sent to Node2

3.1 Node1: Has finished computation. Suggested strategies:
           * The server is notified that Node1 has finished the computation and 
           is now waiting for server's next request (give data; discard task)
           #TODO: 1) what kind of notification? with or without meta? 2) polling here?
           ** The results are sent to the server.
           #TODO: if the amount of results is HUGE (megabytes), should we send
           # them in multiple requests?    
           The results consist of two parts: the data and metadata. Metadata
           is a JSON object which contains information about data size, its hash
           time spent for generation etc.                      
    Dispatcher: ** NodeController() --> {ProjectX}.Controller();
    Controller: Finds the session data of the task by given ID. The task has
        not expired. As described previously, our ProjectManager is not able to 
        verify the correctness of the results. The Controller uses 'comparison'
        strategy to decide whether the results are correct or not.
        #TODO: Node-side code could include checksum generation, so that it 
        # could be verified on server. Just to make sure that NodeX is not 
        # cheating
        Storage();
    Storage: Storage accepts metadata and data from the controller. In this case
        we need a storage that can add a reference to data which could be kept
        on a disk. The ID of the stored data is the same as outer Task's ID. 
        #TODO: Decide, what fields do we need here? It's obviously Task's 
        # innerID and NodeID, metainformation etc. 
    Controller: Since there is nothing to do according to the comparison 
        strategy (storage has only once result for {task}, controller will send 
        next task to Node1.
        PM(); # see 2.1
    ...
3.2 Node2: --||--
    Controller: Now storage contains two results for {task}. The comparison 
        shows that the results are similar. We ask storage to keep only one 
        result (get rid of duplicates). 
        Storage(); PM();
    Storage: ...
    PM: Is notified by Controller that the results for {task} are ready. The 
        ID of the results in storage are passed to PM, which has a full control
        of them. 

4. The whole process continues unless the PM reports that there is nothing 
   to be done (e.g. Controller asks PM for next task and PM returns None)
                    


==========================

Case 2. 
Consider an app, where all calculations are made by humans, e.g. manual captcha 
recognition, space orbit calculation etc. This doesn't differ much from an 
ordinary case, except that the results from a user may come in minutes or even hours. 
Let's also consider a case, where the solution of the problem can be checked
on the Server side via Project Manager. 

